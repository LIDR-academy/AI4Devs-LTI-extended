---
description: 
globs: 
alwaysApply: true
---
# Reglas y Patrones del Proyecto LTI

## Documentacion
Hay documentación relevante relativa a arquitectura, modelo de datos, buenas prácticas...que expande estas reglas. Se encuentran en backend/documentation y en README.md.

## Patrones de Arquitectura

1. **Domain-Driven Design (DDD)**
   - El proyecto sigue principios de DDD con modelos de dominio claros
   - Las entidades deben tener identidad única y métodos que implementen lógica de negocio
   - Los Value Objects deben ser inmutables y representar conceptos sin identidad
   - El dominio debe mantenerse limpio de detalles de infraestructura

2. **Arquitectura en Capas**
   - Presentación: Controllers/Routes en backend, Componentes en frontend
   - Aplicación: Servicios de aplicación, coordinan operaciones complejas
   - Dominio: Core del negocio, entidades, value objects, servicios de dominio
   - Infraestructura: Implementaciones técnicas, repositorios, DB, etc.

3. **Repository Pattern**
   - Toda interacción con la base de datos debe pasar por repositorios
   - Los repositorios deben devolver modelos de dominio, no DTOs o entidades Prisma

## Patrones de Implementación

1. **Prisma ORM**
   - Las consultas complejas deben optimizarse con `include` selectivo
   - Usar transacciones para operaciones que afecten a múltiples tablas
   - Evitar buscar datos no necesarios en cada consulta

2. **API REST**
   - URLs deben ser recursos en plural (ej. /candidates, /positions)
   - Usar correctamente los métodos HTTP (GET, POST, PUT, DELETE)
   - Respuestas API deben seguir estructura estándar con status y data/error

3. **React Components**
   - Componentes funcionales con hooks preferidos sobre componentes de clase
   - Reutilización de componentes mediante composición
   - Formularios controlados para toda entrada de datos

## Convenciones de Código

1. **TypeScript**
   - Siempre definir tipos para parámetros y retornos de funciones
   - Evitar el uso de `any` cuando sea posible
   - Utilizar interfaces para modelar estructuras de datos
   - Preferir type safety sobre casting de tipos

2. **Nombres**
   - Entidades/Clases: PascalCase (Candidate, Position)
   - Interfaces: PascalCase con prefijo I (ICandidate)
   - Métodos/Funciones: camelCase (createCandidate)
   - Variables: camelCase (candidateList)
   - Constantes globales: UPPER_SNAKE_CASE (API_URL)

3. **Estructura de Archivos**
   - Un componente React por archivo
   - Nombres de archivos de componentes en PascalCase
   - Archivos de servicios y utilidades en camelCase
   - Tests en archivos `.spec.ts` o `.test.ts`

## Preferencias de Desarrollo

1. **Estilos de Codificación**
   - Preferir funciones puras cuando sea posible
   - Evitar efectos secundarios no documentados
   - Utilizar async/await sobre promesas encadenadas
   - Destructuring para extraer propiedades de objetos
   - Template strings para concatenación de cadenas

2. **Manejo de Estado**
   - Evitar estado global cuando no sea necesario
   - Usar Context API para estado compartido entre componentes
   - Estado local con useState para componentes individuales
   - Considerar useReducer para estados complejos

3. **Validación**
   - Validar entrada en frontend y backend
   - Mensajes de error claros y específicos
   - Preferir validación temprana (fail fast)

## Patrones de Testing
1. **Testing Backend**
   - Unit tests para lógica de dominio y servicios
   - Integration tests para repositories y controladores
   - Tests automatizados para APIs
   - Los tests deben seguir el nombre del servicio/controlador/... y terminar en .test. Ej: para candidateService.ts, todos los tests irían en candidateService.test.ts

2. **Testing Frontend**
   - Unit tests para lógica de componentes
   - Integration tests para flujos de usuario
   - Preferir testing-library sobre enzyme

## Flujos de Trabajo

1. **Gestión de Dependencias**
   - Especificar versiones exactas en package.json
   - Revisar vulnerabilidades antes de añadir nuevas dependencias
   - Mantener actualizadas las dependencias críticas

2. **Desarrollo**
   - Desarrollo basado en features
   - Code review para todos los cambios significativos
   - Documentar decisiones arquitectónicas importantes 

